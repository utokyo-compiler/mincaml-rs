use sourcemap::{Loc, Spanned};
use syntax::{*, ExprKind::*, LitKind::*, IntBinOpKind::*, RelationBinOpKind::*, FloatBinOpKind::*, UnOp::*};

use crate::lexer::{Error as LexError, Token};
use super::Allocator;

grammar<'input, 'ctx>(alloc: Allocator<'ctx>);
extern {
    type Location = Loc;
    type Error = LexError<'input>;

    enum Token<'input> {
        "(" => Token::LPar,
        ")" => Token::RPar,
        Bool => Token::Bool(<bool>),
        Int => Token::Int(<i32>),
        Float => Token::Float(<f32>),
        Ident => Token::Ident(<&'input str>),
        "-" => Token::Hyphen,
        "+" => Token::Plus,
        "*" => Token::Ast,
        "/" => Token::Slash,
        "-." => Token::HyphenDot,
        "+." => Token::PlusDot,
        "*." => Token::AstDot,
        "/." => Token::SlashDot,
        "=" => Token::Equal,
        "<>" => Token::LessGreater,
        "<=" => Token::LessEqual,
        ">=" => Token::GreaterEqual,
        "<" => Token::Less,
        ">" => Token::Greater,
        "if" => Token::If,
        "then" => Token::Then,
        "else" => Token::Else,
        "let" => Token::Let,
        "in" => Token::In,
        "rec" => Token::Rec,
        "," => Token::Comma,
        "Array.make" => Token::ArrayMake,
        "." => Token::Dot,
        "<-" => Token::LessHyphen,
        ";" => Token::Semi,
    }
}

pub Expr: Expr<'ctx> = {
    ExprOpen,
    ExprClosed,
}

ExprOpen: Expr<'ctx> = {
    ExprMacro<ExprOpen>,
    Seq,
}

ExprClosed: Expr<'ctx> = ExprMacro<ExprClosed>;

ExprMacro<TrailExpr>: Expr<'ctx> = {
    Let<TrailExpr>,

    // Expression that can have semicolon, which is a *singularity* of the OCaml syntax.
    <l:@L> <e1:SeqClosed> ";" <e2:TrailExpr> <r2:@R>
        => alloc.spanned(Then(e1, e2), (l, r2)),
}

Seq: Expr<'ctx> = {
    SeqOpen,
    SeqClosed,
}

SeqOpen: Expr<'ctx> = SeqMacro<ExprOpen, SeqOpen>;

SeqClosed: Expr<'ctx> = {
    SeqMacro<ExprClosed, SeqClosed>,
    BinaryExpr,
}

// Expression that can follow `else` or `<-`
SeqMacro<TrailExpr, TrailSelf>: Expr<'ctx> = {
    // `if` inside of (`if` or `set`) or `if`
    // Note: min-caml allows semicolon in then branch.
    <l:@L> "if" <e1:Expr> "then" <e2:Expr> "else" <e3:TrailSelf> <r2:@R>
        => alloc.spanned(If(e1, e2, e3), (l, r2)),

    // `set` inside of (`if` or `set`) or `set`
    <l:@L> <e1:SimpleExpr> "<-" <e2:TrailSelf> <r2:@R>
        => alloc.spanned(Set(e1, e2), (l, r2)),

    // `if e1 then e2 else let ..` or `e1 <- let ..` or `let ..`
    //
    // Looking ahead the semicolon after the second expression (e:Expr) in `Let`
    // should trigger the shift action to OptionalSemi rule within `Expr` in `Let`,
    // not the reduce action here. i.e., semicolon wins let.
    <l:@L> "if" <e1:Expr> "then" <e2:Expr> "else" <e3:Let<TrailExpr>> <r2:@R>
        => alloc.spanned(If(e1, e2, e3), (l, r2)),

    // `set` inside of (`if` or `set`) or `set`
    <l:@L> <e1:SimpleExpr> "<-" <e2:Let<TrailExpr>> <r2:@R>
        => alloc.spanned(Set(e1, e2), (l, r2)),
}

// Expression that starts with let
Let<TrailExpr>: Expr<'ctx> = {
    <l:@L> "let" <binder:LetBinder> "in" <e:TrailExpr> <r:@R>
        => alloc.spanned(Let(binder, e), (l, r)),
}

LetBinder: LetBinder<'ctx> = {
    <x:SpannedIdent> "=" <val:Expr>
        => LetBinder::let_var(x, val),

    "rec" <x:SpannedIdent> <arg:FormalArgs> "=" <val:Expr>
        => LetBinder::let_rec(x, arg, val),

    <p:Pat> "=" <val:Expr>
        => LetBinder::let_tuple(p, val),
}

SpannedIdent: Spanned<Ident<'ctx>> = {
    <l:@L> <x:Ident> <r:@R> => Spanned::new(alloc.ctx().intern_ident(x), (l, r)),
}

TermOp: BinOp = {
    "+" => BinOp::Int(Add),
    "-" => BinOp::Int(Sub),
    "+." => BinOp::Float(FAdd),
    "-." => BinOp::Float(FSub)
};

FactorOp: BinOp = {
    "*" => BinOp::Int(Mul),
    "/" => BinOp::Int(Div),
    "*." => BinOp::Float(FMul),
    "/." => BinOp::Float(FDiv)
};

RelationBinOp: BinOp = {
    "=" => BinOp::Relation(Eq),
    "<=" => BinOp::Relation(Le),
    ">=" => BinOp::Relation(Ge),
    "<>" => BinOp::Relation(Ne),
    "<" => BinOp::Relation(Lt),
    ">" => BinOp::Relation(Gt)
};

Literal: Expr<'ctx> = {
    <l:@L> "(" ")" <r:@R> => alloc.spanned(Const(Unit), (l, r)),
    <l:@L> <x:Bool> <r:@R> => alloc.spanned(Const(Bool(x)), (l, r)),
    <l:@L> <x:Int> <r:@R> => alloc.spanned(Const(Int(x)), (l, r)),
    <l:@L> <x:Float> <r:@R> => alloc.spanned(Const(Float(x.to_bits())), (l, r)),
}

SimpleExpr: Expr<'ctx> = {
    "(" <x:Expr> ")" => x,
    <l:@L> "(" <e:Elems> ")" <r:@R>
        => alloc.spanned(Tuple(e), (l, r)),
    Literal,
    <l:@L> <x:Ident> <r:@R> => alloc.spanned(Var(alloc.ctx().intern_ident(x)), (l, r)),
    <l:@L> <s:SimpleExpr> "." "(" <x:Expr> ")" <r:@R> => alloc.spanned(Get(s, x), (l, r)),
}

// Binary operation or higher
BinaryExpr: Expr<'ctx> = {
    #[precedence(level="0")]
    SimpleExpr,

    // (a b)
    #[precedence(level="1")]
    <l:@L> <e1:SimpleExpr> <e2:ActualArgs> <r:@R>
        => alloc.spanned(App(e1, e2), (l, r)),
    <l:@L> "Array.make" <e1:SimpleExpr> <e2:BinaryExpr> <r:@R>
        => alloc.spanned(ArrayMake(e1, e2), (l, r)),

    // -
    #[precedence(level="2")]
    <l:@L> "-" <e1:BinaryExpr> <r:@R>
        => alloc.spanned(Unary(Neg, e1), (l, r)),

    // -.
    <l:@L> "-." <e1:BinaryExpr> <r:@R>
        => alloc.spanned(Unary(FNeg, e1), (l, r)),

    // * *. /.
    #[precedence(level="3")]
    #[assoc(side="left")]
    <l:@L> <e1:BinaryExpr> <op:FactorOp> <e2:BinaryExpr> <r:@R>
        => alloc.spanned(Binary(op, e1, e2), (l, r)),

    // + - +. -.
    #[precedence(level="4")]
    #[assoc(side="left")]
    <l:@L> <e1:BinaryExpr> <op:TermOp> <e2:BinaryExpr> <r:@R>
        => alloc.spanned(Binary(op, e1, e2), (l, r)),

    // = <> < > <= >=
    #[precedence(level="5")]
    #[assoc(side="left")]
    <l:@L> <e1:BinaryExpr> <op:RelationBinOp> <e2:BinaryExpr> <r:@R>
        => alloc.spanned(Binary(op, e1, e2), (l, r)),
}

FormalArgs: Vec<Spanned<Ident<'ctx>>> = {
    <mut a:FormalArgs> <ident:SpannedIdent> => {
        a.push(ident);
        a
    },
    SpannedIdent => vec![<>],
}

ActualArgs: Vec<Expr<'ctx>> = {
    <mut a:ActualArgs> <s:SimpleExpr> => {
        a.push(s);
        a
    },
    SimpleExpr => vec![<>],
}

Elems: Vec<Expr<'ctx>> = {
    <mut a:Elems> "," <i:Expr> => {
        a.push(i);
        a
    },
    <i1:Expr> "," <i2:Expr> => vec![i1, i2],
}

PatRaw: Vec<Spanned<Ident<'ctx>>> = {
    <mut a:PatRaw> "," <ident:SpannedIdent> => {
        a.push(ident);
        a
    },
    <ident1:SpannedIdent> "," <ident2:SpannedIdent> => vec![ident1, ident2],
}

Pat: Vec<Spanned<Ident<'ctx>>> = {
    PatRaw,
    "(" <p:PatRaw> ")" => p,
}
